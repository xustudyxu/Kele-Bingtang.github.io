(window.webpackJsonp=window.webpackJsonp||[]).push([[179],{706:function(t,s,a){"use strict";a.r(s);var _=a(15),v=Object(_.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#协调节点"}},[t._v("协调节点")])]),a("li",[a("a",{attrs:{href:"#写流程"}},[t._v("写流程")])]),a("li",[a("a",{attrs:{href:"#读流程"}},[t._v("读流程")])]),a("li",[a("a",{attrs:{href:"#更新流程"}},[t._v("更新流程")])]),a("li",[a("a",{attrs:{href:"#多文档操作流程"}},[t._v("多文档操作流程")]),a("ul",[a("li",[a("a",{attrs:{href:"#mget流程"}},[t._v("mget流程")])]),a("li",[a("a",{attrs:{href:"#bulk-api流程"}},[t._v("bulk API流程")])])])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"协调节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协调节点"}},[t._v("#")]),t._v(" 协调节点")]),t._v(" "),a("p",[t._v("我们假设有一个集群由三个节点组成。它包含一个叫 kele 的索引，有两个主分片，每个主分片有两个副本分片。相同分片的副本不会放在同一节点。")]),t._v(" "),a("p",[t._v("在 "),a("strong",[t._v("Postman")]),t._v(" 发送 "),a("code",[t._v("PUT")]),t._v(" 请求：http://127.0.0.1:7001/kele")]),t._v(" "),a("p",[t._v("请求体内容：")]),t._v(" "),a("div",{staticClass:"language-json line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"settings"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"number_of_shards"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"number_of_replicas"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[a("img",{attrs:{src:"https://fastly.jsdelivr.net/gh/Kele-Bingtang/static/img/ElasticSearch/20211116200930.png",alt:"image-20211116200929707"}})]),t._v(" "),a("p",[t._v("集群状态：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://fastly.jsdelivr.net/gh/Kele-Bingtang/static/img/ElasticSearch/20211116221444.png",alt:"image-20211116200953146"}})]),t._v(" "),a("p",[t._v("通过 elasticsearch-head 插件查看集群情况，所以我们的集群是一个有三个节点和一个索引的集群")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://fastly.jsdelivr.net/gh/Kele-Bingtang/static/img/ElasticSearch/20211116201045.png",alt:"image-20211116201042084"}})]),t._v(" "),a("p",[t._v("我们可以发送请求到集群中的任一节点。每个节点都有能力处理任意请求。每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上。 在下面的例子中，将所有的请求发送到 Node 7001，我们将其称为 "),a("mark",[t._v("协调节点(coordinating node)")]),t._v("。也可以理解为转发到其他节点的节点。")]),t._v(" "),a("div",{staticClass:"custom-block note"},[a("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),a("p",[t._v("当发送请求的时候，为了扩展负载，更好的做法是"),a("mark",[t._v("轮询")]),t._v("集群中所有的节点。")]),t._v(" "),a("div",{staticClass:"custom-block right"},[a("p",[t._v("2021-11-16 @Young Kbt")])])]),t._v(" "),a("h2",{attrs:{id:"写流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#写流程"}},[t._v("#")]),t._v(" 写流程")]),t._v(" "),a("div",{staticClass:"custom-block note"},[a("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),a("p",[t._v("为了便于区分节点个数。Node 7001 是 Node 1，Node 7002 是 Node 2，Node 7003 是 Node 3。")]),t._v(" "),a("div",{staticClass:"custom-block right"},[a("p",[t._v("2021-11-16 @Young Kbt")])])]),t._v(" "),a("p",[t._v("新建、索引和删除请求都是"),a("code",[t._v("写")]),t._v("操作，必须在"),a("mark",[t._v("主分片")]),t._v("上面完成写入操作之后"),a("mark",[t._v("才能被复制")]),t._v("到相关的副本分片")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://fastly.jsdelivr.net/gh/Kele-Bingtang/static/img/ElasticSearch/20211116214258.png",alt:"image-20211116214258075"}})]),t._v(" "),a("p",[t._v("写操作步骤顺序：")]),t._v(" "),a("ol",[a("li",[t._v("客户端向 Node 1 发送新建、索引或者删除请求")]),t._v(" "),a("li",[t._v("节点使用文档的 "),a("code",[t._v("_id")]),t._v(" 确定文档属于分片 "),a("code",[t._v("P0")]),t._v("。请求会被转发到 Node 3，因为分片 "),a("code",[t._v("P0")]),t._v(" 的主分片目前被分配在 Node 3 上")]),t._v(" "),a("li",[t._v("Node 3 在主分片上面执行请求。如果成功了，它将请求并行转发到 Node 1 和 Node 2 的副本分片上。一旦所有的副本分片都报告成功，Node 3 将向协调节点报告成功，协调节点向客户端报告成功")])]),t._v(" "),a("p",[t._v("在客户端收到成功响应时，文档变更已经在主分片和所有副本分片执行完成，"),a("mark",[t._v("变更是安全的")]),t._v("。有一些可选的请求参数允许您影响这个过程，可能以数据安全为代价提升性能。这些选项很少使用，因为 Elasticsearch 已经很快处理了，但是为了完整起见，请参考下面表格：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("参数")]),t._v(" "),a("th",[t._v("含义")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("consistency")]),t._v(" "),a("td",[t._v("consistency，即一致性。在默认设置下，即使仅仅是在试图执行一个_写_操作之前，主分片都会要求必须要有规定数量(quorum)（或者换种说法，也即必须要有大多数）的分片副本处于活跃可用状态，才会去执行"),a("code",[t._v("写")]),t._v("操作(其中分片副本 可以是主分片或者副本分片)。这是为了避免在发生网络分区故障（network  partition）的时候进行"),a("code",[t._v("写")]),t._v("操作，进而导致数据不一致。"),a("code",[t._v("规定数量")]),t._v("即："),a("br"),a("strong",[t._v("int( (primary + number_of_replicas) / 2 ) + 1")]),a("br"),a("br"),t._v("consistency 参数的值可以设为 "),a("code",[t._v("one")]),t._v(" （只要主分片状态 ok 就允许执行"),a("code",[t._v("写")]),t._v("操 作）,"),a("code",[t._v("all")]),t._v("（必须要主分片和所有副本分片的状态没问题才允许执行_写_操作），或 quorum。默认值为 quorum， 即大多数的分片副本状态没问题就允许执行"),a("code",[t._v("写")]),t._v(" 操作。"),a("br"),t._v("注意，规定数量的计算公式中 number_of_replicas 指的是在索引设置中的设定副本分片数，而不是指当前处理活动状态的副本分片数。如果你的索引设置中指定了当前索引拥有三个副本分片，那规定数量的计算结果即："),a("br"),a("strong",[t._v("int( (primary + 3 replicas) / 2 ) + 1 = 3")]),a("br"),t._v("如果此时你只启动两个节点，那么处于活跃状态的分片副本数量就达不到规定数量，也因此您将无法检索和删除任何文档。")])]),t._v(" "),a("tr",[a("td",[t._v("timeout")]),t._v(" "),a("td",[t._v("如果没有足够的副本分片会发生什么？Elasticsearch 会等待，希望更多的分片出现。默认情况下，它最多等待 1 分钟。如果你需要，你可以使用 timeout 参数使它更早终止：100 100 毫秒，30s 是 30 秒。")])])])]),t._v(" "),a("div",{staticClass:"custom-block note"},[a("p",{staticClass:"custom-block-title"},[t._v("笔记")]),t._v(" "),a("p",[t._v("新索引默认有 1 个副本分片，这意味着为满足规定数量应该需要两个活动的分片副本。但是，这些默认的设置会阻止我们在单一节点上做任何事情。为了避免这个问题，要求只有当 number_of_replicas 大于 1 的时候，规定数量才会执行。")]),t._v(" "),a("div",{staticClass:"custom-block right"},[a("p",[t._v("2021-11-16 @Young Kbt")])])]),t._v(" "),a("h2",{attrs:{id:"读流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#读流程"}},[t._v("#")]),t._v(" 读流程")]),t._v(" "),a("p",[t._v("我们可以从主分片或者从其它任意副本分片检索文档")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://fastly.jsdelivr.net/gh/Kele-Bingtang/static/img/ElasticSearch/20211116215314.png",alt:"image-20211116215313313"}})]),t._v(" "),a("p",[t._v("读流程顺序步骤：")]),t._v(" "),a("ol",[a("li",[t._v("客户端向 Node 1 发送获取请求")]),t._v(" "),a("li",[t._v("节点使用文档的 "),a("code",[t._v("_id")]),t._v(" 来确定文档属于分片 "),a("code",[t._v("P0")]),t._v("。分片 "),a("code",[t._v("P0")]),t._v(" 的副本分片存在于所有的三个节点上。在这种情况下，它将请求转发到 Node 2")]),t._v(" "),a("li",[t._v("Node 2 将文档返回给 Node 1，然后将文档返回给客户端")])]),t._v(" "),a("p",[a("strong",[t._v("每次都是 Node 2返回文档数据吗？")])]),t._v(" "),a("p",[t._v("不是，采用轮询。")]),t._v(" "),a("p",[t._v("在处理读取请求时，协调节点在每次请求的时候都会通过"),a("mark",[t._v("轮询")]),t._v("所有的副本分片来达到负载均衡。在文档被检索时，已经被检索的文档可能已经存在于主分片上，但是还没有复制到副本分片。在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。")]),t._v(" "),a("h2",{attrs:{id:"更新流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新流程"}},[t._v("#")]),t._v(" 更新流程")]),t._v(" "),a("p",[t._v("部分更新一个文档，结合了之前的读和写流程：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://fastly.jsdelivr.net/gh/Kele-Bingtang/static/img/ElasticSearch/20211116215816.png",alt:"image-20211116215739265"}})]),t._v(" "),a("p",[t._v("更新流程步骤顺序：")]),t._v(" "),a("ol",[a("li",[t._v("客户端向 Node 1 发送更新请求")]),t._v(" "),a("li",[t._v("节点使用文档的 "),a("code",[t._v("_id")]),t._v(" 来确定文档属于分片 "),a("code",[t._v("P0")]),t._v("，它将请求转发到主分片所在的 Node 3,因为分片 "),a("code",[t._v("P0")]),t._v(" 的主分片目前被分配在 Node 3 上")]),t._v(" "),a("li",[t._v("Node 3 从主分片检索文档，修改 "),a("code",[t._v("_source")]),t._v(" 字段中的 JSON 数据，并且尝试"),a("mark",[t._v("重新检索")]),t._v("主分片的文档。如果文档已经被另一个进程修改，它会重试步骤 3，超过 retry_on_conflict 次数后放弃")]),t._v(" "),a("li",[t._v("如果 Node 3 成功地更新文档，它将新版本的文档并行转发到 Node 1 和 Node 2 上的副本分片，重新建立索引。一旦所有副本分片都返回成功，Node 3 向协调节点也返回成功，协调节点向客户端返回成功")])]),t._v(" "),a("p",[a("strong",[t._v("主分片同步到副本分片时，是转发更新请求吗？")])]),t._v(" "),a("p",[t._v("不是。当主分片把更改转发到副本分片时，它"),a("mark",[t._v("不会")]),t._v("转发更新请求。相反，它"),a("mark",[t._v("转发完整文档的新版本")]),t._v("。请记住，这些数据更改文档将会异步转发到副本分片，并且不能保证数据更改文档以发送它们相同的顺序到达。如果 Elasticsearch 仅转发更改请求，则可能以错误的顺序应用更改，导致得到损坏的文档。")]),t._v(" "),a("h2",{attrs:{id:"多文档操作流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多文档操作流程"}},[t._v("#")]),t._v(" 多文档操作流程")]),t._v(" "),a("h3",{attrs:{id:"mget流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mget流程"}},[t._v("#")]),t._v(" mget流程")]),t._v(" "),a("p",[a("code",[t._v("mget")]),t._v(" 和 bulk API 的模式类似于单文档模式。区别在于协调节点"),a("mark",[t._v("知道")]),t._v("每个文档存在于哪个分片中。它将整个多文档请求分解成「每个分片」的多文档请求，并且将这些请求并行转发到每个参与节点。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://fastly.jsdelivr.net/gh/Kele-Bingtang/static/img/ElasticSearch/20211116221002.png",alt:"image-20211116220937664"}})]),t._v(" "),a("p",[t._v("用单个 "),a("code",[t._v("mget")]),t._v(" 请求取回多个文档所需的步骤顺序:")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("客户端向 Node 1 发送 mget 请求")])]),t._v(" "),a("li",[a("p",[t._v("Node 1 为每个分片构建多文档获取请求，然后"),a("mark",[t._v("并行转发")]),t._v("这些请求到托管在每个所需的主分片或者副本分片的节点上。一旦收到所有答复，Node 1 构建响应并将其返回给客户端")])])]),t._v(" "),a("p",[t._v("可以对 docs 数组中每个文档设置 routing 参数")]),t._v(" "),a("h3",{attrs:{id:"bulk-api流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bulk-api流程"}},[t._v("#")]),t._v(" bulk API流程")]),t._v(" "),a("p",[a("code",[t._v("bulk API")]),t._v(" 允许在单个批量请求中执行多个创建、索引、删除和更新请求")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://fastly.jsdelivr.net/gh/Kele-Bingtang/static/img/ElasticSearch/20211116221146.png",alt:"image-20211116221145907"}})]),t._v(" "),a("p",[a("code",[t._v("bulk API")]),t._v(" 按执行步骤顺序：")]),t._v(" "),a("ol",[a("li",[t._v("客户端向 Node 1 发送 "),a("code",[t._v("bulk")]),t._v(" 请求")]),t._v(" "),a("li",[t._v("Node 1 为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机")]),t._v(" "),a("li",[t._v("主分片一个接一个按顺序执行每个操作。当每个操作成功时，主分片"),a("mark",[t._v("并行转发")]),t._v("新文档（或删除）到副本分片，然后执行下一个操作。一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。")])])])}),[],!1,null,null,null);s.default=v.exports}}]);