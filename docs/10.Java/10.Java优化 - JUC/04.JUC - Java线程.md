---
title: JUC - Java线程
date: 2022-05-04 18:10:24
permalink: /java/juc/java/
categories:
  - JUC
tags: 
  - JUC
---

[[TOC]]



## 创建和运行线程

### 使用 Thread

直接使用 Thread 线程类创建线程。

```java
public class Test {
    public static void main(String[] args) {
        // 创建线程对象
        Thread t = new Thread() {
            public void run() {
                // 要执行的任务
            }
        };
        // 启动线程
        t.start();
    }
}
```

例如：

```java
public class Test {
    public static void main(String[] args) {
        // 构造方法的参数是给线程指定名字，推荐
        Thread t1 = new Thread("t1") {
            @Override
            // run 方法内实现了要执行的任务
            public void run() {
                log.debug("hello");
            }
        };
        t1.start();
    }
}
```

输出：

```java
19:19:00 [t1] c.ThreadStarter - hello
```

### 使用 Runnable

Runnable 是任务，Thread 是线程，把线程和任务（要执行的代码）分开。

- Thread 代表线程
- Runnable 可运行的任务（线程要执行的代码）

```java
public class Test {
    public static void main(String[] args) {
        // 构造方法的参数是给线程指定名字，推荐
        Thread t1 = new Thread("t1") {
            @Override
            // run 方法内实现了要执行的任务
            public void run() {
                log.debug("hello");
            }
        };
        t1.start();
    }
}
```

例如：

```java
public class Test {
    public static void main(String[] args) {
        // 创建任务对象
        Runnable task2 = new Runnable() {
            @Override
            public void run() {
                log.debug("hello");
            }
        };
        // 参数1 是任务对象; 参数2 是线程名字，推荐
        Thread t2 = new Thread(task2, "t2");
        t2.start();
    }
}
```

输出：

```java
19:19:00 [t2] c.ThreadStarter - hello
```

Java 8 以后可以使用 lambda 精简代码

```java
public class Test {
    public static void main(String[] args) {
        // 创建任务对象
        Runnable task2 = () -> log.debug("hello");
        // 参数1 是任务对象; 参数2 是线程名字，推荐
        Thread t2 = new Thread(task2, "t2");
        t2.start();
    }
}
```

### 原理之 Thread 与 Runnable 的关系

`new Thread(new Runnable)` 的部分源码：

```java
// new Thread(new Runnable) 的方法如下：
public Thread(Runnable target) {
    init(null, target, "Thread-" + nextThreadNum(), 0);
    // 省略 ...
    this.target = target;
}
@Override
public void run() {
    if (target != null) {
        target.run();
    }
}
```

可以看到传入的 Runnable 被存在 Thread 的 target 变量里，然后调用 `run()` 方法时，其实就是调用 Runnable 的 `run()` 方法。

- 建议 Runnable 实现多线程，这样可以让 Thread 线程类和 Runnable 任务类分开，实现组合调用
- 用 Runnable 更容易与线程池等高级 API 配合
- 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活

### 使用 FutureTask

FutureTask 配合 Thread 使用，和 Runnable 类似，只不过 FutureTask 能有返回值。

FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况。

```java
public class Test {
    public static void main(String[] args) {
        // 创建任务对象
        FutureTask<Integer> task3 = new FutureTask<>(() -> {
            log.debug("hello");
            return 100;
        });
        // 参数 1 是任务对象; 参数 2 是线程名字，推荐
        new Thread(task3, "t3").start();
        // 主线程阻塞，同步等待 task 执行完毕的结果
        Integer result = task3.get();
        System.out.println("结果是：" + result);  // 结果是：100
    }
}
```

## 查看进程线程的方法

### Windows

- 任务管理器可以查看进程和线程数，也可以用来杀死进程
- `tasklist` 查看进程
- `taskkill` 杀死进程

### linux

- `ps -fe` 查看所有进程
- `ps -fT -p` 查看某个进程（PID）的所有线程
- `kill` 杀死进程
- `top` 按大写 H 切换是否显示线程
- `top -H -p` 查看某个进程（PID）的所有线程

### Java

- `jps` 命令查看所有 Java 进程
- jstack  查看某个 Java 进程（PID）的所有线程状态
- jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）

> jconsole 远程监控配置

需要以如下方式运行你的 Java 类：

```sh
java -Djava.rmi.server.hostname=`ip地址` -Dcom.sun.management.jmxremote -
Dcom.sun.management.jmxremote.port=`连接端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 -
Dcom.sun.management.jmxremote.authenticate=是否认证 java类
```

如果要 jconsole 认证访问，还需要做如下步骤

- 复制 jmxremote.password 文件
- 修改 jmxremote.password 和 jmxremote.access 文件的权限为 600 即文件所有者可读写
- 连接时填入 controlRole（用户名），R&D（密码）

## 原理之线程运行

### 栈与栈帧

我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。

- **一个线程对应一个栈**，每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存
- 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

代码：

```java
public class TestFrames {
    public static void main(String[] args) {
        method1(10);
    }

    private static void method1(int x) {
        int y = x + 1;
        Object m = method2();
        System.out.println(m);
    }

    private static Object method2() {
        Object n = new Object();
        return n;
    }
}
```

效果图：

![image-20220505143457430](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/juc/20220505143532.png)



栈的相关内容具体看 [JVM - 虚拟机栈](/java/jvm/vm-stack/)。

### 线程上下文切换

线程上下文切换（Thread Context Switch）。

因为以下一些原因导致 CPU 不再执行当前的线程，转而执行另一个线程的代码。

- 线程的 CPU 时间片用完
- 垃圾回收
- 有更高优先级的线程需要运行
- 线程自己调用了 `sleep`、`yield`、`wait`、`join`、`park`、`synchronized`、`lock` 等方法

当线程上下文切换发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念是程序计数器（Program Counter Register），它的作用是记住下一条 JVM 指令的执行地址，是线程私有的。

状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等，线程上下文切换频繁发生会影响性能。

## 线程常见方法
